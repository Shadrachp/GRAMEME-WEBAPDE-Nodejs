/**
 * Copyright (c) 2016 Sqreen. All Rights Reserved.
 * Please refer to our terms for more information: https://www.sqreen.io/terms.html
 */
/**
 * Code modified from https://github.com/othiym23/node-continuation-local-storage by Forrest L Norvell (othiym23)
 * Original code is under BSD-2-Clause license with the following copyright
 * ```
 * Copyright (c) 2013-2016, Forrest L Norvell <ogd@aoaioxxysz.net>
 * All rights reserved.
 * ```
 */
'use strict';
const AsyncHooks = require('async_hooks');

const Assert = require('assert');
const WrapEmitter = require('emitter-listener');

let listenerCount = 0;

const asyncListenerMap = new Map();

const AsyncListener = class {

    constructor(hooks) {

        this.create = hooks.create;
        this.before = hooks.before;
        this.after = hooks.after;
        this.error = hooks.error;

        this.store = new Map();

        const self = this;
        this.hook = AsyncHooks.createHook({
            init(asyncId) {

                self.store.set(asyncId, self.create());
            },
            before(asyncId) {
                //$lab:coverage:off$
                if (self.store.has(asyncId)) {//$lab:coverage:on$
                    self.before(null, self.store.get(asyncId));
                }
            },
            after(asyncId) {

                if (self.store.has(asyncId)) {
                    self.after(null, self.store.get(asyncId));
                }
            },
            destroy(asyncId) {

                self.store.delete(asyncId);
            }
        });

        this.id = ++listenerCount;
        asyncListenerMap.set(this.id, this);
    }

    enable() {

        this.hook.enable();
    }

    disable() {

        this.hook.disable();
    }
};

const addAsyncListener = function (hooks) {

    const asyncListener = new AsyncListener(hooks);
    asyncListener.enable();
    return asyncListener.id;
};

const removeAsyncListener = function (id) {

    if (!asyncListenerMap.has(id)) {
        return;
    }
    const asyncListener = asyncListenerMap.get(id);
    asyncListener.disable();
    asyncListenerMap.delete(id);
};

/*
 *
 * CONSTANTS
 *
 */
const CONTEXTS_SYMBOL = 'cls@contexts';
const ERROR_SYMBOL = 'error@context';

class Namespace {

    constructor(name) {

        this.name   = name;
        // changed in 2.7: no default context
        this.active = null;
        this._set   = [];
        this.id     = null;
    }

    set(key, value) {

        if (!this.active) {
            throw new Error('No context available. ns.run() or ns.bind() must be called first.');
        }

        this.active[key] = value;
        return value;
    }

    get(key) {
        //$lab:coverage:off$
        if (!this.active) {
            return undefined;//$lab:coverage:on$
        }

        return this.active[key];
    }

    createContext() {

        return Object.create(this.active);
    }

    run(fn) {

        const context = this.createContext();
        this.enter(context);
        try {
            fn(context);
            return context;
        }
        catch (exception) {
            if (exception) {
                exception[ERROR_SYMBOL] = context;
            }
            throw exception;
        }
        finally {
            this.exit(context);
        }
    }

    runAndReturn(fn) {

        let value;
        this.run((context) => {

            value = fn(context);
        });
        return value;
    }

    bind(fn, context) {
        //$lab:coverage:off$
        if (!context) {//$lab:coverage:on$
            if (!this.active) {
                context = this.createContext();
            }
            else {
                context = this.active;
            }
        }

        const self = this;
        return function () {

            self.enter(context);
            try {
                return fn.apply(this, arguments);
            }
            catch (exception) {
                if (exception) {
                    exception[ERROR_SYMBOL] = context;
                }
                throw exception;
            }
            finally {
                self.exit(context);
            }
        };
    }

    enter(context) {

        Assert.ok(context, 'context must be provided for entering');

        this._set.push(this.active);
        this.active = context;
    }

    exit(context) {

        Assert.ok(context, 'context must be provided for exiting');

        // Fast path for most exits that are at the top of the stack
        if (this.active === context) {
            Assert.ok(this._set.length, 'can\'t remove top context');
            this.active = this._set.pop();
            return;
        }

        // Fast search in the stack using lastIndexOf
        const index = this._set.lastIndexOf(context);

        Assert.ok(index >= 0, 'context not currently entered; can\'t exit');
        Assert.ok(index, 'can\'t remove top context');

        this._set.splice(index, 1);
    }

    bindEmitter(emitter) {

        Assert.ok(emitter.on && emitter.addListener && emitter.emit, 'can only bind real EEs');

        const namespace = this; // eslint-disable-line
        const thisSymbol = 'context@' + this.name;

        // Capture the context active at the time the emitter is bound.
        const attach = function (listener) {

            //$lab:coverage:off$
            if (!listener) {
                return;
            }
            if (!listener[CONTEXTS_SYMBOL]) {
                listener[CONTEXTS_SYMBOL] = Object.create(null);
            }


            listener[CONTEXTS_SYMBOL][thisSymbol] = {
                namespace,
                context: namespace.active
            };
            //$lab:coverage:on$
        };

        // At emit time, bind the listener within the correct context.
        const bind = function (unwrapped) {

            //$lab:coverage:off$
            if (!(unwrapped && unwrapped[CONTEXTS_SYMBOL])) {
                return unwrapped;
            }

            let wrapped  = unwrapped;
            const contexts = unwrapped[CONTEXTS_SYMBOL];
            Object.keys(contexts).forEach((name) => {

                const thunk = contexts[name];
                wrapped = thunk.namespace.bind(wrapped, thunk.context);
            });
            return wrapped;
            //$lab:coverage:on$
        };

        WrapEmitter(emitter, attach, bind);
    }

    /**
     * If an error comes out of a namespace, it will have a context attached to it.
     * This function knows how to find it.
     *
     * @param {Error} exception Possibly annotated error.
     */
    fromException(exception) {

        //$lab:coverage:off$
        return exception[ERROR_SYMBOL];
        //$lab:coverage:on$
    }
}

const getNamespace = function (name) {

    return process.namespaces[name];
};

const createNamespace = function (name) {

    Assert.ok(name, 'namespace must be given a name!');

    const namespace = new Namespace(name);
    namespace.id = addAsyncListener({
        create : function () {

            return namespace.active;
        },
        before : function (context, storage) {

            if (storage) {
                namespace.enter(storage);
            }
        },
        after  : function (context, storage) {

            if (storage) {
                namespace.exit(storage);
            }
        },
        error  : function (storage) {

            if (storage) {
                namespace.exit(storage);
            }
        }
    });

    process.namespaces[name] = namespace;
    return namespace;
};

const destroyNamespace = function (name) {

    const namespace = getNamespace(name);

    Assert.ok(namespace, 'can\'t delete nonexistent namespace!');
    Assert.ok(namespace.id, 'don\'t assign to process.namespaces directly!');

    removeAsyncListener(namespace.id);
    process.namespaces[name] = null;
};

const reset = function () {

    // must unregister async listeners
    if (process.namespaces) {
        Object.keys(process.namespaces).forEach((name) => {

            destroyNamespace(name);
        });
    }
    process.namespaces = Object.create(null);
};

//$lab:coverage:off$
if (!process.namespaces) { // call immediately to set up
    reset();
}
//$lab:coverage:on$

const getMap = function () {

    return asyncListenerMap;
};

module.exports = {
    getNamespace,
    createNamespace,
    destroyNamespace,
    reset,
    addAsyncListener,
    removeAsyncListener,
    getMap
};

