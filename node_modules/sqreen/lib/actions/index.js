/**
 * Copyright (c) 2016 - 2018 Sqreen. All Rights Reserved.
 * Please refer to our terms for more information: https://www.sqreen.io/terms.html
 */
'use strict';
const IPRange = require('ip-range-check');
const Hoek = require('hoek');

const CBUtils = require('../rules/rules-callback/utils');

const ipIsInSet = function (ip, set, take_first) {

    for (const item of set) {
        const range = item.ip_cidr;
        if (take_first && IPRange(ip, item[0].ip_cidr)) {
            return item
        }
        else if (IPRange(ip, range)) {
            return item;
        }
    }
    return null;
};

let blockedRanges = new Set();
let redirects = new Map();
let blockedUsers = new Set();


const init = module.exports.init = function () {
    blockedRanges = new Set();
    redirects = new Map();
    blockedUsers = new Set();
};

const ACTION = {
    BLOCK_IP: 'block_ip',
    REDIRECT_IP: 'redirect_ip',
    BLOCK_USER: 'block_user'
};

const report = function (actionName, output, req, action_id) {

    const SDK = require('../sdk/index');

    return SDK._track(`sq.action.${actionName}`, {
        properties: {
            output,
            action_id
        }

    }, req);
};

const placeInSetFor = function (item, set, duration) {

    duration = (duration || 0) * 1000; //(s => ms)
    set.add(item);
    if (duration > 0) {
        setTimeout(() => {

            set.delete(item);
        }, duration);
    }
};

const ACTION_CALLBACK = {
    [ACTION.BLOCK_IP](parameters, duration, id) {

        const ip_cidr = parameters.ip_cidr;
        placeInSetFor({ ip_cidr, id }, blockedRanges, duration);
        return true;
    },
    [ACTION.REDIRECT_IP](parameters, duration, id) {

        const ip_cidr = parameters.ip_cidr;
        duration = (duration || 0) * 1000; //(s => ms)
        if (typeof parameters.url !== 'string') {
            throw new Error(`Cannot create redirect action as ${parameters.url} is not a string.`);
        }
        const item = { ip_cidr, id };
        redirects.set(item, parameters.url);

        if (duration > 0) {
            setTimeout(() => {

                redirects.delete(item);
            }, duration);
        }

        return true;
    },
    [ACTION.BLOCK_USER](parameters, duration, id) {

        if (!parameters.users || !Array.isArray(parameters.users)) {
            throw new Error(`bad action parameters ${JSON.stringify(parameters)}`);
        }
        const todo = { users: parameters.users, id };
        placeInSetFor(todo, blockedUsers, duration);
        return true;
    }
};

module.exports.userIsBanned = function (user, req) {

    for (const action of blockedUsers) {
        for (const usr of action.users) {
            if (Hoek.deepEqual(user, usr)) {
                CBUtils.dropRequest(['', req, req.__sqreen_res]);
                report(ACTION.BLOCK_USER, user, req, action.id);
                return true;
            }
        }
    }
    return false;
};

module.exports.shouldLetThisGo = function (req, res, ip) {

    const blockRange = ipIsInSet(ip, blockedRanges, false);
    if (blockRange !== null) {
        // Current IP is blocked, let's do this
        CBUtils.dropRequest(['', req, res]);
        report(ACTION.BLOCK_IP, { ip_address: ip }, req, blockRange.id);
        return false;
    }

    const redirectRange = ipIsInSet(ip, redirects, true);
    if (redirectRange !== null) {
        // Current IP is redirected, let's do this
        const target = redirectRange[1];
        CBUtils.redirectRequest(['', req, res], target);
        report(ACTION.REDIRECT_IP, { ip_address: ip }, req, redirectRange[0].id);
        return false;
    }

    return true;
};

const applyAction = function (action, parameters, duration, id) {

    if (ACTION_CALLBACK[action] === undefined) {
        throw new Error(`unsupported action ${action}`);
    }

    return ACTION_CALLBACK[action](parameters, duration, id);
};

module.exports.enforceActionList = function (list) {

    init();
    const failedList = [];
    list.forEach((action) => {

        let failed = false;
        try {
            failed = !applyAction(action.action, action.parameters, action.duration, action.action_id);
        }
        catch (e) {
            require('../exception/index').report(e).catch(() => {});
            failed = true
        }
        if (failed === true) {
            failedList.push(action.action_id);
        }
    });
    return failedList;
};

